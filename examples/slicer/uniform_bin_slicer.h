// copyright ################################# //
// This file is part of the Xfields Package.   //
// Copyright (c) CERN, 2021.                   //
// ########################################### //

#ifndef XFIELDS_UNIFORM_BIN_SLICER_H
#define XFIELDS_UNIFORM_BIN_SLICER_H


/*gpufun*/
void UniformBinSlicer_slice(UniformBinSlicerData el,
                LocalParticle* part0,
                /*gpuglmem*/ int64_t* i_slice_part,
                /*gpuglmem*/ int64_t* i_bunch_part){

    int64_t const num_slices = UniformBinSlicerData_get_num_slices(el);
    double const z_min = UniformBinSlicerData_get_z_min(el);
    double const dzeta = UniformBinSlicerData_get_dzeta(el);

    int64_t const num_bunches = UniformBinSlicerData_get_num_bunches(el);
    int64_t const i_bunch_0 = UniformBinSlicerData_get_i_bunch_0(el);
    double const bunch_spacing_zeta = UniformBinSlicerData_get_bunch_spacing_zeta(el);
    double* particles_per_slice = UniformBinSlicerData_getp1_particles_per_slice(el, 0);

    // Generated by:
    // coords = ['x', 'px', 'y', 'py', 'zeta', 'delta']
    // for cc in coords:
    //     print(f"double* sum_{cc} = UniformBinSlicerData_getp1_sum_{cc}(el, 0);")
    double* sum_x = UniformBinSlicerData_getp1_sum_x(el, 0);
    double* sum_px = UniformBinSlicerData_getp1_sum_px(el, 0);
    double* sum_y = UniformBinSlicerData_getp1_sum_y(el, 0);
    double* sum_py = UniformBinSlicerData_getp1_sum_py(el, 0);
    double* sum_zeta = UniformBinSlicerData_getp1_sum_zeta(el, 0);
    double* sum_delta = UniformBinSlicerData_getp1_sum_delta(el, 0);

    // Generated by:
    // moms = ['xx', 'xpx', 'xy', 'xpy', 'xzeta', 'xdelta',
    //    'pxpx', 'pxy', 'pxpy', 'pxzeta', 'pxdelta',
    //    'yy', 'ypy', 'yzeta', 'ydelta',
    //    'pypy', 'pyzeta', 'pydelta',
    //    'zetazeta', 'zetadelta',
    //    'deltadelta']
    // for mm in moms:
    //    print(f"double* sum_{mm} = UniformBinSlicerData_getp1_sum_{mm}(el, 0);")

    double* sum_xx = UniformBinSlicerData_getp1_sum_xx(el, 0);
    double* sum_xpx = UniformBinSlicerData_getp1_sum_xpx(el, 0);
    double* sum_xy = UniformBinSlicerData_getp1_sum_xy(el, 0);
    double* sum_xpy = UniformBinSlicerData_getp1_sum_xpy(el, 0);
    double* sum_xzeta = UniformBinSlicerData_getp1_sum_xzeta(el, 0);
    double* sum_xdelta = UniformBinSlicerData_getp1_sum_xdelta(el, 0);
    double* sum_pxpx = UniformBinSlicerData_getp1_sum_pxpx(el, 0);
    double* sum_pxy = UniformBinSlicerData_getp1_sum_pxy(el, 0);
    double* sum_pxpy = UniformBinSlicerData_getp1_sum_pxpy(el, 0);
    double* sum_pxzeta = UniformBinSlicerData_getp1_sum_pxzeta(el, 0);
    double* sum_pxdelta = UniformBinSlicerData_getp1_sum_pxdelta(el, 0);
    double* sum_yy = UniformBinSlicerData_getp1_sum_yy(el, 0);
    double* sum_ypy = UniformBinSlicerData_getp1_sum_ypy(el, 0);
    double* sum_yzeta = UniformBinSlicerData_getp1_sum_yzeta(el, 0);
    double* sum_ydelta = UniformBinSlicerData_getp1_sum_ydelta(el, 0);
    double* sum_pypy = UniformBinSlicerData_getp1_sum_pypy(el, 0);
    double* sum_pyzeta = UniformBinSlicerData_getp1_sum_pyzeta(el, 0);
    double* sum_pydelta = UniformBinSlicerData_getp1_sum_pydelta(el, 0);
    double* sum_zetazeta = UniformBinSlicerData_getp1_sum_zetazeta(el, 0);
    double* sum_zetadelta = UniformBinSlicerData_getp1_sum_zetadelta(el, 0);
    double* sum_deltadelta = UniformBinSlicerData_getp1_sum_deltadelta(el, 0);

    double const z_min_edge = z_min - 0.5 * dzeta;

    //start_per_particle_block (part0->part)
        double zeta = LocalParticle_get_zeta(part);
        double weight = LocalParticle_get_weight(part);
        const int64_t ipart = part->ipart;

        int64_t i_bunch;
        double z_min_edge_bunch = z_min_edge;
        uint8_t can_be_assigned_to_slice = 0;

        if (num_bunches <= 0){
            i_bunch = 0;
            can_be_assigned_to_slice = 1;
        }
        else{
            i_bunch = floor((zeta - z_min_edge) / bunch_spacing_zeta);
            if (i_bunch >= i_bunch_0 && i_bunch < num_bunches){
                i_bunch_part[ipart] = i_bunch;
                z_min_edge_bunch = z_min_edge + i_bunch * bunch_spacing_zeta;
                can_be_assigned_to_slice = 1;
            } else {
                i_bunch_part[ipart] = -1;
                can_be_assigned_to_slice = 0;
            }
        }

        int64_t i_slice = floor((zeta - z_min_edge_bunch) / dzeta);
        if (can_be_assigned_to_slice && i_slice >= 0 && i_slice < num_slices){
            i_slice_part[ipart] = i_slice;

            atomicAdd(&particles_per_slice[i_slice + i_bunch * num_slices], weight);

            // Generated by:
            // coords = ['x', 'px', 'y', 'py', 'zeta', 'delta']
            // for cc in coords:
            //     print(f"atomicAdd(&sum_{cc}[i_slice + i_bunch * num_slices], weight * LocalParticle_get_{cc}(part));")

            atomicAdd(&sum_x[i_slice + i_bunch * num_slices], weight * LocalParticle_get_x(part));
            atomicAdd(&sum_px[i_slice + i_bunch * num_slices], weight * LocalParticle_get_px(part));
            atomicAdd(&sum_y[i_slice + i_bunch * num_slices], weight * LocalParticle_get_y(part));
            atomicAdd(&sum_py[i_slice + i_bunch * num_slices], weight * LocalParticle_get_py(part));
            atomicAdd(&sum_zeta[i_slice + i_bunch * num_slices], weight * LocalParticle_get_zeta(part));
            atomicAdd(&sum_delta[i_slice + i_bunch * num_slices], weight * LocalParticle_get_delta(part));

            // atomicAdd(&sum_xx[i_slice + i_bunch * num_slices],
            //            weight * LocalParticle_get_x(part) * LocalParticle_get_x(part));

        } else {
            i_slice_part[ipart] = -1;
        }


    //end_per_particle_block

}

/*gpufun*/
void UniformBinSlicer_track_local_particle(UniformBinSlicerData el,
                LocalParticle* part0){

}

#endif